/***********************************************************************/
/*                                                                     */
/*  FILE        :CONT_.c                                               */
/*  DATE        :Mon, Sep 05, 2016                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :H8/3687                                               */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.16).    */
/*                                                                     */
/***********************************************************************/
              
// P50 : エンコーダA相(白)
// P51 : エンコーダB相(橙)
// P52 : モータ側センサ出力
// P53 : 壁側センサ出力
// J71 : モータ +側印加電圧(赤)
// J72 : モータ -側印加電圧(黒)

#include "iodefine.h"
#include "lcd_func.h"
#include <machine.h>

int pulse = 0;
int state = 0;

void WKP_func(void);	// WKP割込処理
void SW1_moveLeft(void);	// SW1~4割込処理
void SW2_moveLeft50(void);
void SW3_moveRight50(void);
void SW4_moveRight(void);


void main(void);
#ifdef __cplusplus
extern "C" {
void abort(void);
}
#endif

void main(void)
{
	lcd_init();          // LCD初期化

	// 割込設定
	IO.PMR1.BYTE = 0xF0; // SW1~4
	IEGR1.BYTE = 0x7F;	 // 立ち上がり
	IRR1.BYTE = 0x30;    // 割込フラグクリア
	// WKP割込設定
	IO.PCR5 = 0xFD;			// P51(B相)は入力
	IO.PMR5.BYTE = 0x0D;	// P50(A相),52(ﾓｰﾀ側ｾﾝｻ),53(壁側ｾﾝｻ)は割込
	IO.PUCR5.BYTE = 0xFF;	// プルアップ
	IEGR2.BYTE = 0xCF;		// 立ち上がり
	IWPR.BYTE = 0x00;		// 割込フラグクリア
	// タイマ設定
	TZ0.TCR.BYTE = 0x23;	// プリスケーラ等設定
	TZ0.POCR.BYTE = 0xF8;	// ローアクティブ
	TZ.TPMR.BYTE = 0x8E;	// モータ出力端子をPWM制御
	TZ.TOCR.BYTE = 0x0C;	// 端子初期出力は0
	TZ0.GRA = 25000;		// 周期設定
	TZ0.GRC = 0;
	TZ0.GRD = 0;
	
	IENR1.BYTE = 0x1F;	    // SW1~4割込許可
	IENR1.BIT.IENWP = 1;	// WKP割込許可
	
	while(1);
}

void WKP_func(void)
{
	// A相のパルス割込
	if(IWPR.BIT.IWPF0 == 1) {
		// 50mm移動のときのみの処理
		if(state == 2 || state == 3) {
			if(pulse >= 618) {
				// 50ミリ移動していた場合、モータ停止
				TZ.TOER.BIT.EC0 = 1; 
				TZ.TOER.BIT.ED0 = 1; 
				TZ0.GRC = 0;
				TZ0.GRD = 0;
				TZ.TSTR.BIT.STR0 = 0;
				state = 0;
				pulse = 0;
			}
			else {
				pulse += 1;
			}
		}
	}
// モータ側センサ割込
	if(IWPR.BIT.IWPF2 == 1) {
		// 左移動中ならばモータ停止
		if(state == 1 || state == 2) {
			TZ.TOER.BIT.EC0 = 1; 
			TZ.TOER.BIT.ED0 = 1; 
			TZ0.GRC = 0;
			TZ0.GRD = 0;
			TZ.TSTR.BIT.STR0 = 0;
			state = 0;
			pulse = 0;
		}
	}
	
	// 壁側センサ割込
	if(IWPR.BIT.IWPF3 == 1) {
		// 右移動中ならばモータ停止
		if(state == 3 || state == 4) {
			
			TZ.TOER.BIT.EC0 = 1; 
			TZ.TOER.BIT.ED0 = 1; 
			TZ0.GRC = 0;
			TZ0.GRD = 0;
			TZ.TSTR.BIT.STR0 = 0;
			state = 0;
			pulse = 0;
		}
	}
		
	IWPR.BYTE = 0x00;
}

void SW1_moveLeft(void) {
	state = 1;
	pulse = 0;
	TZ0.GRC = 0;
	TZ0.GRD = 15000;
	TZ.TOER.BIT.ED0 = 0;
	TZ0.TCNT = 0;
	TZ.TSTR.BIT.STR0 = 1;
	
	IRR1.BIT.IRRI0 = 0;
}

void SW2_moveLeft50(void)
{
	state = 2;
	pulse = 0;
	TZ0.GRC = 0;
	TZ0.GRD = 15000;
	TZ.TOER.BIT.ED0 = 0;
	TZ0.TCNT = 0;
	TZ.TSTR.BIT.STR0 = 1;
	
	IRR1.BIT.IRRI1 = 0;
}

void SW3_moveRight50(void)
{
	state = 3;
	pulse = 0;
	TZ0.GRC = 15000;
	TZ0.GRD = 0;
	TZ.TOER.BIT.EC0 = 0;
	TZ0.TCNT = 0;
	TZ.TSTR.BIT.STR0 = 1;
	
	IRR1.BIT.IRRI2 = 0;
}

void SW4_moveRight(void) {
	state = 4;
	pulse = 0;
	TZ0.GRC = 15000;
	TZ0.GRD = 0;
	TZ.TOER.BIT.EC0 = 0;
	TZ0.TCNT = 0;
	TZ.TSTR.BIT.STR0 = 1;
	
	IRR1.BIT.IRRI3 = 0;
}

#ifdef __cplusplus
void abort(void)
{

}
#endif
